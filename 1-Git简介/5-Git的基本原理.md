# Git 的基本原理

#   哈希算法

哈希算法也叫散列算法，是一类算法的统称。哈希算法满足这样的关系：![img](https://cdn.nlark.com/yuque/__latex/8d72bab474df1a6d60b6a587f0804478.svg)。即输入任意长度的数据 (data)，经过哈希处理后将输出一个定长的数据 （key）。

哈希算法的特性：

1. 对于 data 和 key，哈希运算的过程是不可逆的，即无法由 key 逆推出 data；
2. 不管输入数据的数据量有多大，输入同一个哈希算法，得到的加密结果长度固定；

1. 哈希算法确定，输入数据确定，输出数据也将确定；
2. 哈希算法确定，输入数据有变化，输出数据一定有变化，而且通常变化很大；

1. 输入数据不定长，而输出的哈希值却是固定长度的，即哈希值是一个有限集合；
2. “哈希碰撞”（不同的输入数据对应了相同的哈希值）是必然会发生的，因此一个成熟的哈希算法应有较好的抗冲突性；

1. 密码上常用的 MD5，SHA 等都是哈希算法，因为 key 的长度（碰撞空间）较大，所以常常用作密码校验。

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/932482/1635517041005-ecf9698f-990b-467a-a1ac-c16b6565946e.jpeg)

Git 底层采用 SHA-1 算法，从根本上保证数据完整性。

#   Git 的版本保存机制

## 集中式版本控制工具的文件管理机制

以文件变更列表的方式存储信息。

这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635517378402-e8cc52a6-5860-456b-90ca-6591a41d5edb.png)

## 分布式版本控制工具的文件管理机制

Git 把数据看作小型文件系统的一组快照。

每次提交更新时 Git 都会对当前的全部文件生成一个快照并保存这个快照的索引。若文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。所以 Git 以快照流的方式工作。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635517472404-b592db59-ffe1-47f3-bf72-1dbc38e73e6e.png)

1. 接受提交对象

提交对象包含文件树、作者、提交者等信息，其中的文件树为各个工作区的文件进行哈希运算，得到由哈希值组成的树。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635517618424-4345d209-5f00-47b7-893c-75a14ee3e968.png)

1. 将提交对象与父对象产生链接

各个提交事件均属于快照。除了根提交 (root commit) 外，每一个提交事件都有父事件 (parent) 参与链接。通过版本间的“父子关系”组织历史记录。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635517669164-406c9170-88ae-4023-870b-70903b2809f5.png)

#   Git 的分支管理机制

## 分支的创建

分支从初始化了的根提交 (root commit) 中产生，每一次提交都以当前的提交事件作为父节点创建新的提交，实现分支的延伸。全部分支名称统一使用一个`HEAD`指针指示当前本地库（或工作区）的分支位置及项目状态。移动`HEAD`指针即可实现分支和版本的快速切换。若在同一提交状态下创建了多个分支名称，即`HEAD`指针可指向多个不同分支，则实现了分支的创建。

Git 优于 SVN 系统：创建分支时不必完整地复制全部文件树，而只需在对应快照下新建一个可用于`HEAD`指针移动的分支名称即可——更高效。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635603094626-4aed466b-d5e3-45c2-b424-4d2e9b659b32.png)

当前处于`master`分支的`f30ab`号提交状态。该状态下有 2 各分支名称，可分别参与延伸。

## 分支的切换

将`HEAD`指针指向特定位置完成分支（或版本）的切换。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635603821225-e7c257bd-0d86-47c4-9025-87c1b1fc0359.png)

由`master`分支切换到`testing`分支上。本质上指向的是同一个提交状态。

## 新分支的提交

在新分支上完成版本提交即可。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635604508299-dc11819c-ef90-49a1-a18c-c1c29ef6244c.png)

在`testing`新分支上提交一个新的版本`87ab2`后，指向`testing`的`HEAD`随着提交链的延长而移动，而`master`的指针保持不变。

## 分支的形成

`HEAD`指针回到原始分支的位置产生一个新的提交后，分支形成。

![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635604763828-5782028b-13b6-4291-bcd8-01ae1df2669b.png)　![img](https://cdn.nlark.com/yuque/0/2021/png/932482/1635604773463-b35ebe2f-d359-4518-9c41-326b9db44266.png)

将`HEAD`指针从`testing`分支移动至`master`分支，最后产生一个新的提交事件`c2b9e`。至此分支形成。